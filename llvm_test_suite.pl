my $parallel_opt = "-j 7";

# Use all.lf to store standard output of make and run.
my $make_all_lf = "$optset_work_dir/make_all.lf";
my $run_all_lf = "$optset_work_dir/run_all.lf";

my @test_name_list = ();
my $test_number;
my $short_test_name;
my $test_info;

sub BuildTest
{
    @test_name_list = get_tests_to_run();

    if ( ! -f "./build/CMakeCache.txt")
    {
        # to ignore the check for the clang version
        # it's applicable for the xmain only since it's able to process the bitcode
        if (($compiler =~ ".*xmain.*")||($compiler =~ ".*_icx.*")){
            `sed -i "/set(TEST_SUITE_ENABLE_BITCODE_TESTS/i  set(ENABLE_BITCODE_DEFAULT "True")"  Bitcode/CMakeLists.txt`;
        }
        my ( $code) = run_cmake();
        if ( $code)
        {
            $failure_message = "cmake returned non zero exit code \"$code\"";
            return $COMPFAIL;
        }
    }

    $test_info = get_info();
    my ( $status, $output) = do_build($test_info);
    my $res = "";
    if (-e $make_all_lf)
    {
        my $make_output = file2str("$make_all_lf");
        $res = generate_make_result($make_output);
        my $filtered_output = generate_make_test_lf($make_output);
        $compiler_output .= $filtered_output;
        return $res;
    }

    if ( $status == 0)
    {
        return $PASS;
    }
    elsif ($status == $SKIP)
    {
        return $SKIP;
    }
    else
    {
        $failure_message = "make returned non zero exit code \"$status\"";
        return $COMPFAIL;
    }
}


sub RunTest
{
    my ( $status, $output) = do_run($test_info);
    my $res = "";
    if (-e $run_all_lf)
    {
        my $run_output = file2str("$run_all_lf");
        $res = generate_run_result($run_output);
        my $filtered_output = generate_run_test_lf($run_output);
        $execution_output .= $filtered_output;
        return $res;
    }
    if ( $status == 0)
    {
        return $PASS;
    }
    else
    {
        $failure_message = "lit.py returned non zero exit code \"$status\"";
        return $RUNFAIL;
    }
}

sub do_build
{
    my $r = shift;
    my $cmd = "";
    $test_number = scalar(@test_name_list);
    if ($test_number > 10) {
        if ( ! -e $make_all_lf ) {
           $cmd = "cd ./build/ && make $parallel_opt --keep-going VERBOSE=1 > $make_all_lf 2>&1";
        }
    } else {
        if ($current_test =~ m/avx512/i and !(-e "build/$r->{dir}")) {
           return $SKIP;
        } else {
           $cmd = "cd ./build/$r->{dir} && make $parallel_opt $r->{short_name} VERBOSE=1";
        }
    }

    execute( $cmd);# 1>$makeout 2>$makeerr");
    $compiler_output = "CMD: $cmd\n\n$command_output";

    if (-e $r->{path})
    {
      my $test = "";
      $test = file2str( "$r->{path}");

      # transform absolute path generated by cmake to relative
      # $test =~ s|$ENV{PWD}/||g;
  
      # add execution of test via PIN_CMD
      if ( $ENV{PIN_CMD})
      {
             $test =~ s|^RUN:\s*cd\s*([^\;]*;)|RUN: cd $1 $ENV{PIN_CMD}|g
          || $test =~ s|^RUN:|RUN:$ENV{PIN_CMD}|g;
      }
  
      print2file( $test, $r->{path});
    }
    return $command_status, $command_output;
}

sub do_run
{
    my $r = shift;
    my $path = "$r->{path}";
    my $lit = "./lit/lit.py";
    my $cmd = "";
    
    if ($test_number > 10) {
      if (! -e $run_all_lf) {
        $cmd = "python3 $lit ./build > $run_all_lf 2>&1";
      }
    } else {
      $cmd = "python3 $lit $path";
    }

    # using PIN_CMD to run lit leads to big overhead. So disable it.  But it may be usefull in some cases.
    if ( 0 && $ENV{PIN_CMD})
    {
        $cmd = $ENV{PIN_CMD} . " $cmd";
    }

    execute( $cmd);
    $execution_output = "CMD: $cmd\n\n $command_output";
    return $command_status, $command_output;
}

sub get_info
{
    $test_file = file2str("./config/$current_test.info");
    $test_file =~ /(.*)\.test$/;
    $path = $1;

    my $short_name = basename( $path);
    $short_test_name = "\Q$short_name";
    $path = dirname( $path);
    my $r = { dir => $path, short_name => $short_name, path => "./build/$path/$short_name.test"};

    return $r;
}

sub generate_make_result
{
    my $output = shift;
    my $skip_skx_test = 0;
    if ($current_test =~ m/avx512/i)
    {
      $skip_skx_test = 1;
    }
    for my $line (split /^/, $output){
      if ($line =~ m/\b$short_test_name\b\.dir.* Error/i) {
        # compfail
        $failure_message = "make returned non zero exit code";
        return $COMPFAIL;
      } elsif ($line =~ m/\b$short_test_name\b\] Error/i) {
        #link fail
        $failure_message = "make returned non zero exit code";
        return $COMPFAIL;
      } elsif ($current_test =~ m/avx512/i and $line =~ m/\b$short_test_name\b/i) {
        $skip_skx_test = 0;
      }
    }
    
    return $SKIP if ($skip_skx_test == 1);

    return $PASS;
}

sub generate_run_result
{
    my $output = shift;
    for my $line (split /^/, $output){
      if ($line =~ m/^(.*): test-suite :: .*\b$short_test_name\b\.test \(.*\)$/i) {
        if ($1 =~ m/^PASS/) {
          return $PASS;
        } else {
          #runfail
          $failure_message = "lit.py returned $1";
          return $RUNFAIL;
        }
      }
    }
    
    # Every non-skipped test should have result.
    # If not, it is maybe something wrong in processing result
    return $FILTERFAIL;
}

sub generate_make_test_lf
{
    my $output = shift;
    my $filtered_output = "";

    my $printable = 0;
    for my $line (split /^/, $output) {
      if ($line =~ m/^\[.*\] Building .* object.*\b$short_test_name\b\..*\.o/i) {
        $printable = 1;
        $filtered_output .= $line;
        next;
      }

      if ($line =~ m/^\[.*\] Built target \b$short_test_name\b/i or $line =~ m/^make.*\[.*\b$short_test_name\b.*\] Error/i) {
        $printable = 0;
        $filtered_output .= $line;
        last;
      }

      if ($printable == 1 and $line =~ m/\b$short_test_name\b\./i) {
        $filtered_output .= $line;
      }
    }
    return $filtered_output;
}

sub generate_run_test_lf
{
    my $output = shift;
    my $filtered_output = "";

    my $printable = 0;
    for my $line (split /^/, $output) {
      if ($line =~ m/^.*: test-suite :: .*\b$short_test_name\b\.test \(.*\)$/i) {
        $printable = 1;
        $filtered_output .= $line;
        next;
      }

      if ($printable == 1) {
        if ($line =~ m/^.*: test-suite :: .*\.test \(.*\)$/ or $line =~ m/^Testing Time: /) {
          $printable = 0;
          last;
        } else {
          $filtered_output .= $line;
        }
      }
    }
    return $filtered_output;
}

sub run_cmake
{
    my $c_flags = "$current_optset_opts $compiler_list_options $compiler_list_options_c $opt_c_compiler_flags";
    my $cpp_flags = "$current_optset_opts $compiler_list_options $compiler_list_options_cpp  $opt_cpp_compiler_flags";
    my $c_cmplr = &get_cmplr_cmd('c_compiler');
    my $cpp_cmplr = &get_cmplr_cmd('cpp_compiler');
    my $c_cmd_opts = '';
    my $cpp_cmd_opts = '';

    if ( $c_cmplr =~ /([^\s]*)\s(.*)/)
    {
        $c_cmplr = $1;
        $c_cmd_opts = $2;
    }
    if ( $cpp_cmplr =~ /([^\s]*)\s(.*)/)
    {
        $cpp_cmplr = $1;
        $cpp_cmd_opts = $2;
    }

    my $collect_code_size="Off";
    execute("which llvm-size");
    if ($command_status == 0)
    {
        $collect_code_size="On";
    }

    execute( "mkdir -p build && cd build && cmake ../ -DTEST_SUITE_LIT=../lit/lit.py"
					  . " -DTEST_SUITE_SUBDIRS=\"Bitcode;MicroBenchmarks;MultiSource;SingleSource\""
                                          . " -DCMAKE_BUILD_TYPE=None" # to remove predifined options
                                          . " -DCMAKE_C_COMPILER=\"$c_cmplr\""
                                          . " -DCMAKE_CXX_COMPILER=\"$cpp_cmplr\""
                                          . " -DCMAKE_C_FLAGS=\"$c_cmd_opts $c_flags\""
                                          . " -DCMAKE_CXX_FLAGS=\"$cpp_cmd_opts $cpp_flags\""
                                          . " -DTEST_SUITE_COLLECT_CODE_SIZE=\"$collect_code_size\""
                                          . " > cmake.log"
                                      );
    return $command_status, $command_output;
}

sub file2str
{
    my $file = shift;
    ###
    local $/=undef;
    open FD, "<$file";
    binmode FD;
    my $str = <FD>;
    close FD;
    return $str;
}

sub print2file
{
    my $s = shift;
    my $file = shift;
    ###
    open FD, ">$file";

    print FD $s;
    close FD;
}

sub CleanupTest {
  if ($current_test eq $test_name_list[-1]) {
    rename($make_all_lf, "$make_all_lf.last");
    rename($run_all_lf, "$run_all_lf.last");
  }
}

1;

